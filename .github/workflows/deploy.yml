name: Deploy to Kubernetes

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      version:
        description: 'Version to deploy (tag or sha)'
        required: false
        default: ''
      skip_tests:
        description: 'Skip smoke tests'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

concurrency:
  group: deploy-${{ github.event.inputs.environment || 'staging' }}
  cancel-in-progress: false

jobs:
  # ============================================================================
  # Determine Environment and Version
  # ============================================================================
  prepare:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.vars.outputs.environment }}
      version: ${{ steps.vars.outputs.version }}
      image_tag: ${{ steps.vars.outputs.image_tag }}
    steps:
      - name: Determine variables
        id: vars
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            if [ -n "${{ github.event.inputs.version }}" ]; then
              echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
              echo "image_tag=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
            else
              echo "version=${{ github.sha }}" >> $GITHUB_OUTPUT
              echo "image_tag=${{ github.sha }}" >> $GITHUB_OUTPUT
            fi
          elif [ "${{ github.ref_type }}" == "tag" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "version=${{ github.ref_name }}" >> $GITHUB_OUTPUT
            echo "image_tag=${{ github.ref_name }}" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "version=${{ github.sha }}" >> $GITHUB_OUTPUT
            echo "image_tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # Deploy with Helm
  # ============================================================================
  deploy:
    name: Deploy with Helm
    needs: prepare
    runs-on: ubuntu-latest
    environment:
      name: ${{ needs.prepare.outputs.environment }}
      url: ${{ steps.deploy.outputs.url }}
    permissions:
      contents: read
      packages: read
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: '3.13.0'

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Configure AWS credentials
        if: env.ENVIRONMENT == 'production'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-west-2

      - name: Update kubeconfig
        run: |
          if [ "${{ needs.prepare.outputs.environment }}" == "production" ]; then
            aws eks update-kubeconfig --name cell0-production --region us-west-2
          else
            aws eks update-kubeconfig --name cell0-staging --region us-west-2
          fi

      - name: Create namespace
        run: |
          kubectl create namespace cell0 --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy with Helm
        id: deploy
        run: |
          ENV_FILE="values-${{ needs.prepare.outputs.environment }}.yaml"
          if [ ! -f "helm/cell0/$ENV_FILE" ]; then
            ENV_FILE="values.yaml"
          fi
          
          helm upgrade --install cell0 ./helm/cell0 \
            --namespace cell0 \
            --values helm/cell0/$ENV_FILE \
            --set image.tag=${{ needs.prepare.outputs.image_tag }} \
            --wait \
            --timeout 10m \
            --atomic
          
          echo "url=https://cell0-${{ needs.prepare.outputs.environment }}.example.com" >> $GITHUB_OUTPUT

      - name: Verify deployment
        run: |
          kubectl rollout status deployment/cell0 -n cell0 --timeout=300s
          kubectl get pods -n cell0

  # ============================================================================
  # Smoke Tests
  # ============================================================================
  smoke-test:
    name: Smoke Tests
    needs: [prepare, deploy]
    runs-on: ubuntu-latest
    if: ${{ !github.event.inputs.skip_tests }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-west-2

      - name: Update kubeconfig
        run: |
          if [ "${{ needs.prepare.outputs.environment }}" == "production" ]; then
            aws eks update-kubeconfig --name cell0-production --region us-west-2
          else
            aws eks update-kubeconfig --name cell0-staging --region us-west-2
          fi

      - name: Port forward
        run: |
          kubectl port-forward svc/cell0 18800:18800 -n cell0 &
          sleep 5

      - name: Run smoke tests
        run: |
          # Health check
          curl -f --retry 10 --retry-delay 5 http://localhost:18800/api/health || exit 1
          
          # API status check
          curl -f http://localhost:18800/api/status || exit 1
          
          # Model list check
          curl -f http://localhost:18800/api/models || exit 1

      - name: Kill port forward
        if: always()
        run: pkill kubectl || true

  # ============================================================================
  # ArgoCD Sync (optional)
  # ============================================================================
  argocd-sync:
    name: ArgoCD Sync
    needs: [prepare, deploy]
    runs-on: ubuntu-latest
    if: false  # Enable when ArgoCD is set up
    
    steps:
      - name: Install ArgoCD CLI
        run: |
          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd

      - name: Login to ArgoCD
        run: |
          argocd login ${{ secrets.ARGOCD_SERVER }} \
            --username admin \
            --password ${{ secrets.ARGOCD_PASSWORD }} \
            --insecure

      - name: Sync application
        run: |
          argocd app sync cell0-${{ needs.prepare.outputs.environment }} \
            --prune \
            --force

      - name: Wait for sync
        run: |
          argocd app wait cell0-${{ needs.prepare.outputs.environment }} \
            --health \
            --timeout 600

  # ============================================================================
  # Notify
  # ============================================================================
  notify:
    name: Notify
    needs: [prepare, deploy, smoke-test]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Notify Slack
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ needs.deploy.result }}
          channel: '#deployments'
          fields: repo,message,commit,author,action,eventName,ref,workflow
          text: |
            Deployment to *${{ needs.prepare.outputs.environment }}* ${{ needs.deploy.result == 'success' && 'succeeded' || 'failed' }}
            Version: ${{ needs.prepare.outputs.version }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Create GitHub Deployment
        uses: actions/github-script@v7
        with:
          script: |
            const environment = '${{ needs.prepare.outputs.environment }}';
            const state = '${{ needs.deploy.result }}' === 'success' ? 'success' : 'failure';
            
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: '${{ github.event.deployment.id }}',
              state: state,
              environment: environment,
              environment_url: 'https://cell0-${environment}.example.com'
            });
