/**
 * Cell 0 OS — Shell Completions
 *
 * Generates and installs zsh and bash completion scripts for the cell0 CLI.
 * Completions are placed in ~/.cell0/completions/ and sourced from shell rc files.
 */

import fs from "node:fs";
import path from "node:path";
import os from "node:os";

const CELL0_HOME = path.join(os.homedir(), ".cell0");
const COMPLETIONS_DIR = path.join(CELL0_HOME, "completions");
const ZSH_COMPLETION_FILE = path.join(COMPLETIONS_DIR, "cell0.zsh");
const BASH_COMPLETION_FILE = path.join(COMPLETIONS_DIR, "cell0.bash");

const ZSH_SOURCE_COMMENT = "# Cell 0 OS completions";
const ZSH_SOURCE_LINE = "[[ -f ~/.cell0/completions/cell0.zsh ]] && source ~/.cell0/completions/cell0.zsh";
const BASH_SOURCE_COMMENT = "# Cell 0 OS completions";
const BASH_SOURCE_LINE = "[[ -f ~/.cell0/completions/cell0.bash ]] && source ~/.cell0/completions/cell0.bash";

// ─── Script Generators ───────────────────────────────────────────────────────

export function generateZshCompletion(): string {
    return `#compdef cell0
# Cell 0 OS — zsh completion
# Auto-generated by cell0 completions install
# Source this file or place in $fpath

_cell0() {
  local context state state_descr line
  typeset -A opt_args

  _arguments -C \\
    '1: :->command' \\
    '*: :->args'

  case $state in
    command)
      local commands
      commands=(
        'gateway:Start the WebSocket gateway'
        'status:Show system status'
        'doctor:Run diagnostic checks'
        'onboard:Interactive onboarding wizard'
        'configure:Change settings'
        'portal:Open web dashboard'
        'message:Send a quick message'
        'security:Security audit'
        'update:Update Cell 0 OS'
        'daemon:Manage the gateway service'
        'logs:Tail gateway logs'
        'config:Manage configuration'
        'completions:Manage shell completions'
      )
      _describe 'cell0 commands' commands
      ;;
    args)
      case $line[1] in
        gateway)
          _arguments \\
            '(-p --port)'{-p,--port}'[Gateway port]:port:(18789)' \\
            '(-H --host)'{-H,--host}'[Bind host]:host:(127.0.0.1 0.0.0.0)' \\
            '--python-port[Python backend port]:port:(18800)' \\
            '--no-python[Do not auto-start Python daemon]' \\
            '(-v --verbose)'{-v,--verbose}'[Verbose logging]'
          ;;
        doctor)
          _arguments \\
            '--repair[Auto-fix detected issues]' \\
            '--deep[Run deep checks]'
          ;;
        onboard)
          _arguments \\
            '--install-daemon[Auto-install daemon service]' \\
            '--flow[Onboarding flow]:flow:(quickstart advanced)' \\
            '--accept-risk[Skip risk acknowledgement]' \\
            '--skip-channels[Skip channel setup]' \\
            '--skip-health[Skip health check]'
          ;;
        logs)
          _arguments \\
            '(-f --follow)'{-f,--follow}'[Follow log output]' \\
            '(-n --lines)'{-n,--lines}'[Number of lines]:lines:(50 100 200)' \\
            '--error[Show error log instead]'
          ;;
        daemon)
          local subcommands
          subcommands=(
            'start:Start the gateway service'
            'stop:Stop the gateway service'
            'restart:Restart the gateway service'
            'status:Show service status'
            'install:Install as system service'
            'uninstall:Uninstall system service'
          )
          _describe 'daemon subcommands' subcommands
          ;;
        config)
          local subcommands
          subcommands=(
            'show:Show current configuration'
            'backup:Create a config backup'
            'history:List config backups'
            'restore:Restore from backup'
          )
          _describe 'config subcommands' subcommands
          ;;
        completions)
          local subcommands
          subcommands=(
            'install:Install shell completions'
            'uninstall:Remove shell completions'
            'show:Print completion script'
          )
          _describe 'completions subcommands' subcommands
          ;;
        security)
          _arguments \\
            'audit:Run security audit' \\
            '--deep[Deep audit]' \\
            '--fix[Auto-fix issues]'
          ;;
      esac
      ;;
  esac
}

_cell0 "$@"
`;
}

export function generateBashCompletion(): string {
    return `# Cell 0 OS — bash completion
# Auto-generated by cell0 completions install
# Source: ~/.cell0/completions/cell0.bash

_cell0_complete() {
  local cur prev words cword
  _init_completion || return

  local commands="gateway status doctor message onboard configure portal security update daemon logs config completions"

  if [[ $cword -eq 1 ]]; then
    COMPREPLY=($(compgen -W "$commands" -- "$cur"))
    return
  fi

  case "\${words[1]}" in
    gateway)
      COMPREPLY=($(compgen -W "--port --host --python-port --no-python --verbose" -- "$cur"))
      ;;
    doctor)
      COMPREPLY=($(compgen -W "--repair --deep" -- "$cur"))
      ;;
    onboard)
      COMPREPLY=($(compgen -W "--install-daemon --flow --accept-risk --skip-channels --skip-health" -- "$cur"))
      ;;
    logs)
      COMPREPLY=($(compgen -W "--follow --lines --error" -- "$cur"))
      ;;
    daemon)
      COMPREPLY=($(compgen -W "start stop restart status install uninstall" -- "$cur"))
      ;;
    config)
      COMPREPLY=($(compgen -W "show backup history restore" -- "$cur"))
      ;;
    completions)
      COMPREPLY=($(compgen -W "install uninstall show" -- "$cur"))
      ;;
    security)
      COMPREPLY=($(compgen -W "audit --deep --fix" -- "$cur"))
      ;;
  esac
}

complete -F _cell0_complete cell0
`;
}

// ─── Install / Uninstall ─────────────────────────────────────────────────────

export async function installCompletions(): Promise<void> {
    // 1. Create completions directory if missing
    if (!fs.existsSync(COMPLETIONS_DIR)) {
        fs.mkdirSync(COMPLETIONS_DIR, { recursive: true });
    }

    // 2. Write zsh completion script
    fs.writeFileSync(ZSH_COMPLETION_FILE, generateZshCompletion(), "utf-8");

    // 3. Write bash completion script
    fs.writeFileSync(BASH_COMPLETION_FILE, generateBashCompletion(), "utf-8");

    // 4. Source from ~/.zshrc if it exists and not already sourced
    const zshrcPath = path.join(os.homedir(), ".zshrc");
    if (fs.existsSync(zshrcPath)) {
        const zshrcContent = fs.readFileSync(zshrcPath, "utf-8");
        if (!zshrcContent.includes(ZSH_SOURCE_LINE)) {
            const appendBlock = `\n${ZSH_SOURCE_COMMENT}\n${ZSH_SOURCE_LINE}\n`;
            fs.appendFileSync(zshrcPath, appendBlock, "utf-8");
        }
    }

    // 5. Source from ~/.bashrc if it exists and not already sourced
    const bashrcPath = path.join(os.homedir(), ".bashrc");
    if (fs.existsSync(bashrcPath)) {
        const bashrcContent = fs.readFileSync(bashrcPath, "utf-8");
        if (!bashrcContent.includes(BASH_SOURCE_LINE)) {
            const appendBlock = `\n${BASH_SOURCE_COMMENT}\n${BASH_SOURCE_LINE}\n`;
            fs.appendFileSync(bashrcPath, appendBlock, "utf-8");
        }
    }

    // 6. Print success message
    console.log(
        `Shell completions installed to ${COMPLETIONS_DIR}\n` +
        `  zsh:  ${ZSH_COMPLETION_FILE}\n` +
        `  bash: ${BASH_COMPLETION_FILE}\n` +
        `Restart your shell or run: source ~/.zshrc`
    );
}

export async function uninstallCompletions(): Promise<void> {
    // 1. Remove completion script files if they exist
    if (fs.existsSync(ZSH_COMPLETION_FILE)) {
        fs.rmSync(ZSH_COMPLETION_FILE);
    }
    if (fs.existsSync(BASH_COMPLETION_FILE)) {
        fs.rmSync(BASH_COMPLETION_FILE);
    }

    // 2. Remove source lines from ~/.zshrc
    const zshrcPath = path.join(os.homedir(), ".zshrc");
    if (fs.existsSync(zshrcPath)) {
        let zshrcContent = fs.readFileSync(zshrcPath, "utf-8");
        // Remove the comment line + source line block (with optional leading newline)
        zshrcContent = zshrcContent
            .split("\n")
            .reduce<string[]>((lines, line, idx, arr) => {
                if (line.trim() === ZSH_SOURCE_COMMENT.trim() && arr[idx + 1]?.trim() === ZSH_SOURCE_LINE.trim()) {
                    // Skip this comment line; the source line will be skipped on next iteration via flag
                    lines.push("\x00skip-next");
                } else if (lines[lines.length - 1] === "\x00skip-next") {
                    // Skip the source line
                    lines[lines.length - 1] = "";
                } else {
                    lines.push(line);
                }
                return lines;
            }, [])
            .join("\n");
        // Clean up any double blank lines left behind
        zshrcContent = zshrcContent.replace(/\n{3,}/g, "\n\n");
        fs.writeFileSync(zshrcPath, zshrcContent, "utf-8");
    }

    // 3. Remove source lines from ~/.bashrc
    const bashrcPath = path.join(os.homedir(), ".bashrc");
    if (fs.existsSync(bashrcPath)) {
        let bashrcContent = fs.readFileSync(bashrcPath, "utf-8");
        bashrcContent = bashrcContent
            .split("\n")
            .reduce<string[]>((lines, line, idx, arr) => {
                if (line.trim() === BASH_SOURCE_COMMENT.trim() && arr[idx + 1]?.trim() === BASH_SOURCE_LINE.trim()) {
                    lines.push("\x00skip-next");
                } else if (lines[lines.length - 1] === "\x00skip-next") {
                    lines[lines.length - 1] = "";
                } else {
                    lines.push(line);
                }
                return lines;
            }, [])
            .join("\n");
        bashrcContent = bashrcContent.replace(/\n{3,}/g, "\n\n");
        fs.writeFileSync(bashrcPath, bashrcContent, "utf-8");
    }

    console.log("Shell completions uninstalled.");
}
